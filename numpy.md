# matplotlib+numpy周りのメモ

## 関数を定義してnumpy配列の全要素に対して計算した結果をプロットしたい

２次元データ、３次元描画ってややこしいすぎ

例：配列を引数にしてそれぞれの要素の二乗の和を出す関数

 ```
 def function_2(x):
    return x[0]**2+x[1]**2
 ```

とか
```
def function_2(x):
    if x.ndim == 1:
        return np.sum(x**2)
    else:
        return np.sum(x**2, axis=1)
```
（前者のはあまり良くない例。格子点１つのデータを入れて一つの値を得るにはいいけど、通常想定される格子点の配列のデータには対応できない。
たとえば「ゼロから作るディープラーニング本」の４章で勾配を描画する場合には、このあたりが明確。一つの格子点での計算の定義をno_batch版として、複数の格子点情報を受け取った場合の処理を別に書いてある）


 これをプロットしたい  
 ![](./2d_plot_1.png)

 みたいな図を書きたいってときに、みんなどういう処理してるの？？

### meshgridの話
matplotlibで３Dのデータを書くときに避けて通れない感じの概念、それがmeshgrid  
すごくアバウトには格子点を表現するための型

たとえば、x軸とy軸で範囲が-2,2.5まで、0.25刻みの格子というのはこんな感じで定義される。
```
x0 = np.arange(-2, 2.5, 0.25)
x1 = np.arange(-2, 2.5, 0.25)
#creating meshgrid for matplotlib
X, Y = np.meshgrid(x0, x1)
```


この例だと要素が多いのでもうちょいシンプルな例で見てみよう

```
import numpy as np
x0 = np.arange(0, 3, 1)
x1 = np.arange(1, 4, 1)
#creating meshgrid for matplotlib
X, Y = np.meshgrid(x0, x1)
print(X)
print(Y)
```
この場合、ｘ軸については、0,1,2  
y軸については1,2,3  
をサンプルしているので、考えている格子点の配列をAとすれば
```
A=[[0,1],[0,2],[0,3],[1,1],[1,2],[1,3],[2,1],[2,2],[2,3]]
```
みたいな感じになる。 
meshgridはX,Yの要素が```[X[ij],Y[ij]]=A[ij]```になるようなX,Yを返していると思えば良い。実際、今の場合は出力は
```
[[0 1 2]
 [0 1 2]
 [0 1 2]]
[[1 1 1]
 [2 2 2]
 [3 3 3]]
```
の様になっていて、この関係を満たしている。
ある範囲で刻みを指定した格子点を作るのはこの方法が一番はやいが、meshgridじゃなくて、冒頭に書いたような配列を想定した引数で関数を書いている場合は、「ほしいのはmeshgridちゃうねん、配列やねん…」という感じになる。これをどう解決するかというと、
```
#flatten to creating matrix form
X1 = X.flatten()
Y1 = Y.flatten()
mat=np.array([X1,Y1])
```
のように、flattenと、それ使って入れ子にした配列を２次元配列のように扱える配列定義を組み合わせる。  

matの中身は以下のようになっている

```
[[0 1 2 0 1 2 0 1 2],[1 1 1 2 2 2 3 3 3]]
```
想定通りのAの形に揃えるには、これをさらに転置すればよい。

